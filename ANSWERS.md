_**ВОПРОСЫ:**_
```
1. доделать плагины с erode и dilate, чтобы тестовая аппликация могла продемонстрировать работу с разными плагинами
2. подумать, что будет, если изменить CV_plugin и перекомпилировать тестовую аппликацию, но не перекомпилировать плагины
3. подумать, что будет, если из одного потока создать много асинк-вызовов
4. подумать, как сделать так, чтоб работало без установки собранных либ в систему
```

1. Плагины **erode/dilate** доделаны. Переделан генератор плагинов.
Изменён механизм вызова функции инициализации (через базовый метод).

2. Если изменить базовый класс **CV_plugin**, но не пересобрать библиотеки, то возможны варианты:   
   1) Поменялись методы класса. Тогда в некоторых случаях может помочь механизм проверки "на лету" через **dynamic_cast**. Сейчас это реализовано в файле *CV_wrapper.cpp, строка 25*
   2) Поменялись данные - члены класса. Тут всё несколько хуже, этот кейс описан вот тут:
   https://stackoverflow.com/questions/9188101/recompile-after-base-class-change   
   Какой-то защитой от неконтролируемых изменений может быть версирование.

3. В последнем варианте реализована многопоточность вызовов **processAsync()** одного и того же загруженного плагина. Но сама функция processAsync() сейчас НЕ является потокобезопасной, то есть вызывать её нужно последовательно, запуская при этом параллельные потоки. Если нужно и её саму сделать "многопоточной", тогда необходимо блокировать внутренность функции processAsync() в производных классах.

В текущем варианте не удалось реализовать такой же механизм, как при инициализации (то есть вынести общий код processAsync() в базовую функцию). Возникли сомнения именно в смысле доступа к данным. Если внутренность std::map потокобезопасна, то можно это сделать просто. Иначе нужно лочить.

4. Если не хочется копировать либы в **/usr/local/lib** (а именно там по умолчанию хранятся пользовательские библиотеки), то есть несколько путей:
 - добавить путь в /etc/ld.so.conf.d/*.conf
 - прописать (дописать) в .bashrc переменную **LD_LIBRARY_PATH** с актуальным путём к либам, не забыть выполнить ". .bashrc"
 - выполнить "на лету" ldconfig -n <path_to_libs>
 Подробно описано тут:   
 https://www.thegeekstuff.com/2012/06/linux-shared-libraries
 
PS. Надо сказать, что в процессе работы я получил определённое удовольствие от задачи)
